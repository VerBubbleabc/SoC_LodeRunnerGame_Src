module nexys4_if#(
    parameter integer RESET_POLARITY_LOW = 1
)
(
    input         wrstrb, 
                  rdstrb, 
                  k_wrstrb,
                  sysclk,
    input  [7:0]  port_id,
                  io_data_in, // data requested by the picoblaze 
    
    input  [7:0]  locX, locY, 
                  botinfo, sensors, 
                  lmdist, rmdist, 
                 // upd_sysres,
    input  [4:0]  db_btns,
    input  [15:0] db_sw,
                      
    output reg [7:0]  io_data_out,  // data sent by the picoblaze
    output reg [7:0]  motctl,
    output reg [4:0]  dig0, dig1, dig2,
					  dig3, dig4, dig5, 
					  dig6, dig7, // seven segment digit display
    output reg [7:0]  dec_pts,      // 
    output reg [7:0] led_op_high, 
                     led_op_low,
	
	input       intr_ack,         // rev the signal from the picoblaze	
    input 		intreq_upd_sysreg,           // this signal is gen at every 2 sec
	output reg  interrupt        // send the signal to picoblaze 
);
// data requested by the picoblze 
// send the data through data_out port
// take the note of the input ports used by the picoblaze
always @(posedge sysclk)
begin
// input signals 
// one hot encoded for input signal
    case (port_id[4:0])
        // read the push buttons status
        5'h0:  io_data_out <= {3'b000, db_btns};
        // read the slide swithces status
        // provide the status of the lower order slide swithces 
        5'h1:  io_data_out <=  db_sw[7:0];
        5'hA:  io_data_out <=  locX;
        5'hB:  io_data_out <=  locY;
        5'hC:  io_data_out <=  botinfo;
        5'hD:  io_data_out <=  sensors;
        5'hE:  io_data_out <=  lmdist;  
        5'hF:  io_data_out <=  rmdist;
        5'h10: io_data_out <=  {3'b000, db_btns};
        5'h11: io_data_out <=  db_sw[15:8];
        5'h1A: io_data_out <=  locX;
        5'h1B: io_data_out <=  locY;
        5'h1C: io_data_out <=  botinfo;
        5'h1D: io_data_out <=  sensors;
        5'h1E: io_data_out <=  lmdist;
        5'h1F: io_data_out <=  rmdist;
		default: io_data_out <= 8'bxxxxxxxx;
    endcase
end 

// data sent by the picoblaze 
// take the note of the ports used by the picoblaze 
always @(posedge sysclk)
begin
    if (wrstrb == 1)  // check if the write strobe is generated
    begin
       case (port_id[4:0])  // 
            5'h2:  led_op_low  <= io_data_in;   // show the data on the led's
            5'h3:  dig3      <= io_data_in;
            5'h4:  dig2      <= io_data_in;
            5'h5:  dig1      <= io_data_in;
            5'h6:  dig0      <= io_data_in;
            5'h7:  dec_pts[3:0] <= io_data_in[3:0];
            5'h9:  motctl      <= io_data_in;
            5'h12: led_op_high <= io_data_in;
            5'h13: dig7      <= io_data_in;
            5'h14: dig6      <= io_data_in;
            5'h15: dig5      <= io_data_in;
            5'h16: dig4      <= io_data_in;
            5'h17: dec_pts[7:4] <= io_data_in[3:0];
            5'h19: motctl      <= io_data_in;
            default: led_op_high <= 4'h8;	// breadcrump for debugging
       endcase
    end
end

// on the positive clock edge check if the interrupt is generated by the bot file 
always @ (posedge sysclk) 
begin
    // the interrupt ack is given by the picoblaze after receiving the interrupt 
    // clear the interrupt signal given to the picoblaze 
	if (intr_ack == 1'b1) 
		begin
			interrupt <= 1'b0;
		end
	// the interrupt signal from the bot file is generated 
	// interrupt the picoblaze to notify it of the updated data 	
	else if (intreq_upd_sysreg == 1'b1) 
	begin 
		interrupt <= 1'b1;
	end
	// maintain the status of the interrupt signal to avoid the latch
	else
	begin
		interrupt <= interrupt;
	end
end // always
endmodule
