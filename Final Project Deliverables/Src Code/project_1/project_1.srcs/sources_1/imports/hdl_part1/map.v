//	map.v - World map logic for rojobot systems
//	
//	Copyright Roy Kravitz, 2006-2015, 2016
//
//	Created By:			Roy Kravitz
//	Last Modified:		11-Oct-2014 (RK)
//	
//	Revision History:
//	-----------------
//	Sep-2006		RK		Created this module
//	Jan-2006		RK		Changed map addressing to 128 x 128
//	Jan-2006		RK		Modified to use world map generated by CoreGen
//	Oct-2009		RK		Minor changes (comments only) for conversion to ECE 510
//	Oct-2011		RK		Minor changes (comments only)
//	Oct-2012		RK		Modified for kcpsm6 and Nexys 3
//	Jan-2014		RK		Cleaned up the formatting.  No functional changes	
//	Oct-2014		RK		Checked for Nexys4 and Vivado compatibility.  No changes		
//	
//	Description
//	-----------
//	This module implements the world map for the rojobot to exist in.  It
//	interfaces with the world simulator (implemented in a Picoblaze) and with
//	the VGA logic.
//	
//	The interface to the BOTSIM is through several registers 
//	(produced in world_if.v) that interrogate the map logic (in this module)
//	to find the type of location that Rojobot is on and the sensor readings
//	for the locations around the Rojobot.
//	
//	The interface to the video logic is simpler in that it only returns
//	the value of the location being displayed to the video logic.
//	
//	The major component of map.v is a 16K dual port RAM implemented in two
//	block RAMS.  This RAM is addressed by the simulator
//	with a 7-bit column address and a 7-bit row address.
//
// 	The world map is 128 (cols) by 128 (rows)with each location on the world map
// 	roughly convering 16 (4 x 4) pixels on the 640 x 480 display.  Each location is represented by
// 	two pixels with the following meaning:
//		00 - "ground"   	This is just the background.  No obstruction, no black line
//		01 - "black line"	This location has a black line painted on it
//		10 - "obstruction"	There is an obstruction (like a wall) at this location
//		11-  "reserved"		This is nothing yet so should be treated like "ground"
//
//////////

module maze (

	// interface to external world emulator
	input       [9:0]   scroll_cntr,   // enable the screen rolling // count used will be 128 for image of 256x128
	input 		[9:0]	wrld_col_addr,	// column address of world map location
	input 		[8:0]	wrld_row_addr,	// row address of world map location	
	output		[1:0]	wrld_loc_info,	// map value for location [row_addr, col_addr]

		// interface to the video logic
	input 		[9:0]	vid_row,		// video logic row address
						vid_col,		// video logic column address
	output		[1:0]	vid_pixel_out,	// pixel (location) value

	// interface to the system
	input				clk,			// system clock
						reset			// system reset
);

localparam
	GND		= 2'b00,	// ground - no obstruction, no black line
	BLKL	= 2'b01,	// black line
	OBSTR	= 2'b10,	// obstruction - either border wall or barrier
	RSVD	= 2'b00;	// reserved - treat as "ground" for now
		
		
		
reg 	[18:0] 	wrld_addr; 
reg     [18:0]  vid_addr;	// dual port RAM addresses for 
										// external world emulator and video logic

//always @(posedge clk)
//begin
//    if(reset)      // if reset 
//    begin
//        clk_cnt <= 0;   // clear the clk count 
//    end 
//    else if(clk_cnt == top_clk_cnt)
//    begin
//        clk_cnt <= 0;
//        if((scroll_cntr < 500) && (scrl_bck == 0))
//        begin
//            scroll_cntr <= scroll_cntr + 10;    // keep scrolling till the entire image is displayed
//            //scrl_bck = 1;
//        end     
//        else if(scroll_cntr && (scrl_bck == 1))
//            scroll_cntr <= scroll_cntr - 10;
//        else if((scroll_cntr >= 500) && (scrl_bck == 0))
//        begin 
//            scroll_cntr <= scroll_cntr - 10;
//            scrl_bck = 1;   // start to scroll in reverse
//        end 
//        else 
//        begin
//            scrl_bck = 0;
//            scroll_cntr = 0;    // reset the screen
//        end
//    end
//    else
//    begin
//        clk_cnt <= clk_cnt + 1;
//    end  
//end
reg [31:0] data_wr = 32'hFFFFFFFF; 
reg wr_strb = 0, wr_strb2 = 0;
reg [1:0] dataA = 2'd01, dataB = 2'd01;
reg [2:0]score_old;
reg row_cntr = 0;


// implement the address latches
always @(posedge clk) begin

//    if(score_old != score)
//    begin
//        score_old <= score;
//        if(row_cntr < 5)
//        begin
//          wrld_addr = {PlyrLocX, PlyrLocY};
//        end
//        wr_strb <= 1;
//    end
    
//    if(wr_strb)
//    begin
       
//    end
//    else
	   wrld_addr <= {wrld_row_addr[8:0], wrld_col_addr[9:0]} + scroll_cntr; // 1024x512 image size 
	
	vid_addr <= {vid_row[8:0], vid_col[9:0]} + scroll_cntr;
end
											
// Instantiate the world map ROM (generated by Xilinx Core Gnerator
//world_map MAP (
//	.clka(clk),
//	.addra(wrld_addr),
//	.douta(wrld_loc_info),
//	.clkb(clk),
//	.addrb(vid_addr),       // move the screen window over the entire image 
//	.doutb(vid_pixel_out)
//);	

//world_map_ram MAP(
////// ram changed by PB 
//    .clka(clk),
//	.addra(wrld_addr),
//	.douta(wrld_loc_info),
//	.wea(wr_strb),
//	.dina(dataA),   //2 bits
////// Ram read by VGA
//	.clkb(clk),
//	.addrb(vid_addr),       // move the screen window over the entire image 
//	.doutb(vid_pixel_out),
//	.dinb(dataB),
//	.web(wr_strb2)    
//);
	
World_map MAP (
//world_map_ram MAP (
	.clka(clk),
	.addra(wrld_addr),
	.douta(wrld_loc_info),
	.clkb(clk),
	.addrb(vid_addr),       // move the screen window over the entire image 
	.doutb(vid_pixel_out)
);	
	
endmodule
			
	
		
		
	
						
	